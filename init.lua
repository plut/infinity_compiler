function loadstring(s) return load(s) end
--[[ todo

 - each res/subres is aware of its SQL primary key
   (needed for update)
 - it also has an `index` which serves only for sorting
 
 - subresources
 - control type on assignment
 - assign an object to a resref field: use obj.resref

API for subresources:
 - item.abilities.len(...)
 - item.abilities.push(...)
 - item.abilities[i] i = 0...
 - item.abilities.iterate()
]]--
--Â«Â«1 Preamble
local function strdump(o, level, limit)
	if level == nil then level = 0 end
  if type(o) == 'table' then
		local self_dump = rawget(o, "__dump")
		if type(self_dump) == "string" and level >= 1 then return self_dump end
    local s = '{ '
    local i = 1
		local n = 0
    for k,v in pairs(o) do
			n = n+1
			if type(limit) == type(0) and n > limit then
				s = s..'â€¦'
				break
			end
      if k == i then
        i = i+1
      elseif type(k) == 'string' then
        s = s..'[38;5;65m'..k..'[m='
      else
        s = s..'[[38;5;65m'..k..'[m]='
      end
      s = s.. strdump(v, level+1, limit)..', '
    end
    return s .. '} '
  elseif type(o) == 'string' then
    return '[38;5;25m"'..o..'"[m'
  else
    return tostring(o)
  end
end

local function dump(o, limit)
	print(strdump(o, limit))
end
local function evaldump(s, limit)
	print("[35m"..s.."[m:", strdump(loadstring("return "..s)(), limit))
end
d = evaldump
local function count(tbl)
	local l = 0
	for _, _ in pairs(tbl) do l = l+1 end
	return l
end
local function deep_copy(tbl)
	-- âš  WARNING, this naive implementation does not support cycles!!
	local res = { }
	for k, v in pairs(tbl) do
		if type(v) == "table" then
			res[k] = deep_copy(v)
		else
			res[k] = v
		end
	end
	return res
end

local function mkfn(name)
	return function(...)
	  print("[33;1m"..name.."[m called with: "..strdump(arg))
	end
end
local function mkdisplay(prefix)
	return function(...)
		local s = ""
		for i, v in ipairs({...}) do
			s = s .. tostring(v)
		end
		return "["..prefix.."m"..s.."[m"
	end
end
local red = mkdisplay("31")
local green = mkdisplay("32")
local yellow = mkdisplay("33")
local blue = mkdisplay("34")
local magenta = mkdisplay("35")
local cyan = mkdisplay("36")
local bold = mkdisplay("1")
--Â«Â«1 simulate a mini-version of simod's api
local simod_simul = {}
-- local simod = simod_simul -- comment this line when using real simod
local function table_schema(tbl)
	local sch = simod.schema[tbl]
	if sch == nil then
		error("unknown table: "..tostring(tbl))
	end
	return sch
end
local function schema_fieldtype(tbl, schema, key)
	local v = schema.fields[key]
	if v == nil then
		error("unknown key '"..key.."' in table '"..tbl.."'")
	end
	return v
end
simod_simul.schema = {
-- The schema for a resource includes both payload and context fields.
-- The low-level database interface does not distinguish between these
-- fields; it is the task of the higher-level functions to separate them
-- (when selecting) and collect them (when inserting).
	items = { primary = "itemref", fields =
		{ itemref = "resref", name = "strref", price = "integer",
			weight = "integer", abilities = { "item_abilities" },
		}},
	item_abilities = { primary = "abref", fields =
		{ abref = "auto", itemref = "resref",
			range = "integer", use_icon = "resref", effects = { "item_effects" },
		}},
	item_effects = { primary = "effectref", fields =
		{ effectref = "auto", itemref = "resref", abref = "integer",
			opcode = "integer", target = "integer" }},
}
-- FIXME (?): the schema generated by the Rust side does not contain any
-- link in the (resources) â†’ (subresources) direction;
-- we insert those manually instead:

-- TODO: reinsert this
-- simod.schema.items.fields.abilities = { "item_abilities" }
-- simod.schema.items.fields.effects = { "item_effects" }
-- simod.schema.item_abilities.fields.effects = { "item_effects" }

function simod_simul.list(tbl, condition)
	if tbl == "items" then
		assert(condition == nil)
		return {"sw1h34", "ring", "key"}
	elseif tbl == "item_abilities" then
		assert(condition ~= nil)
		if condition == "sw1h34" then
			return { 1, 2 }
		else return {} end
	elseif tbl == "item_effects" then
		assert(condition ~= nil)
		if condition == "sw1h34" then
			return { 1, 2, 3, 4 }
		end
	end
end
local pseudo_db = {
	items = {
		sw1h34 = { price = 3, weight = 5, name = "Albruin" },
	}, item_abilities = {
		{ itemref = "sw1h34", range = 3, use_icon = "ranged" },
		{ itemref = "sw1h34", range = 0, use_icon = "melee" },
	}, item_effects = {
		{ itemref = "sw1h34", abref = 1, opcode = 1, target = 1 },
		{ itemref = "sw1h34", abref = 1, opcode = 2, target = 1 },
		{ itemref = "sw1h34", opcode = 25, target = 25 },
		{ itemref = "sw1h34", opcode = 26, target = 25 },
	}
}
function simod_simul.select(tbl, resref)
	assert(tbl ~= nil, "nil table in simod.select")
	local sch = table_schema(tbl)
	local fields = {}
	local row = pseudo_db[tbl][resref]
	if row == nil then
		error("pseudo entry not found: "..tbl..":"..resref)
	end
	row = deep_copy(row)
	row[sch.primary] = resref
	return row
end
function simod_simul.update(tbl, resref, key, value)
	assert(tbl ~= nil, "nil table in simod.update")
	local sch = table_schema(tbl)
	if resref == nil then
		error("cannot update resref with nil key in table '"..tbl.."'")
	end
	local ft = schema_fieldtype(tbl, sch, key)
	print(bold('update "', tbl, '" set "', key, "\"='", value,
		"' where \"", sch.primary, "\"='", resref, "'"))
end
function simod_simul.insert(tbl, fields, context)
	assert(tbl ~= nil, "nil tbl in simod.insert")
	local sch = table_schema(tbl)
-- 	print("[35msimod.insert("..tbl.."):[m\n  context="..strdump(context))
	local s1 = "insert into "..tbl.."("
	local s2 = ") values ("
	for fn, ft in pairs(sch.fields) do
		if ft == "auto" then
			-- set new auto field:
			fields[fn] = math.random(10)+300
		elseif type(ft) ~= "table" then
			local v = fields[fn] or context[fn]
			if v == nil then
				error("insert into tbl '"..tbl.."': value not found for '"..fn.."'")
			end
			s1 = s1..'"'..fn..'", '
			s2 = s2.."'"..v.."', "
		else
-- 			print("[36m -- ignoring vector data for field: '"..tbl.."'.'"..fn.."' ("..count(fields[fn]).." entries)[m")
		end
	end
	print(bold(s1, s2))
end

local function todo() error("todo!") end
--Â«Â«1 Methods for resources
-- Resource objects have the following form:
-- { _table = "items", _key = "sw1h34" }
local resource_mt = {}
resource_mt.__index = resource_mt -- sets up inheritance
-- the metatable of `resource_mt`.
-- local root_mt = {}
-- setmetatable(resource_mt, root_mt)
function resource_mt:index(fieldname)
	-- Returns one field of a resource.
	-- This function ends up as meta(resource).__index.
	-- first case: we are accessing a method; look it up in the metatable
	local meta = getmetatable(self)
	-- this will look up either in the metatable, or â€” if the
	-- metametatable's __index method is set, in the appropriate place:
	local method = meta[fieldname]
	if method ~= nil then
		return method
	end
	print("   this is a content field")
	-- second case: we are accessing a content field
	local sch = table_schema(self._table)
	local fields = sch.fields
	local ft = fields[fieldname]
	if ft == nil then
		error('field "'..fieldname..'" not found in table "'..self._table..'"')
	end
	if ft == "subresource" then
		local v = {_table = self._table..'_'..fieldname, _parent = self._key }
-- 		print("indexing with the metatable for resvec: ", strdump(meta))
		local mt = {} -- TODO
		return setmetatable(v, meta.subresources[fieldname])
	end
	return simod.get(self._table, fieldname, self._key)
end
function resource_mt:clone_resource(args)
	-- Clones a resource, modifying values passed as arguments.
	print(yellow("cloning a resource: ", strdump(self)))
	print("  with modifiers: ", strdump(args))
	local sch = table_schema(self._table)
	local fields = sch.fields
	local dk = sch.default_key
	if dk == nil then
		error("only resources with a defined default_key can be cloned")
	end
	print("for table "..self._table.." dk is ", dk)
	local id, changes = normalize_changes(args, dk)
	
	local values = simod.select(self._table, self._key)
	for k,v in pairs(changes) do
		if values[k] == nil then
			error('field "'..k..'" is absent in target')
		end
		values[k] = v
	end
	-- TODO: also clone subresources (recursively)
	-- TODO: if there are any vector data for subresource fields, use it
	-- TODO: insert this into table
	return setmetatable({ _table = self._table, _key = id }, getmetatable(self))
end
function resource_mt:create_resource_mt(table)
	-- create_resource_mt("items")
	-- creates the metatable bound to this .
	local new = {}
	new._table = table
	new.__index = self.index
	new.__call = self.clone_resource
	new.__dump = "[38;5;88m<resource_mt "..table..">[m"
	new.subresources = {}
-- 	return new
	return setmetatable(new, self)
end

--Â«Â«1 Methods for resource vectors (Resvecs)
-- Resource vectors have the following form:
-- { _table = "items_abilities", _parent = "sw1h34" }

local resvec_mt = {}
resvec_mt.__dump = "<resvec_mt>"
function resvec_mt:index(i)
	-- TODO: write an iter() method
	if type(i) ~= "number" then
		error("resvec index must be an integer")
	end
	local list = simod.list(self._table, self._parent)
	if i < 1 or i > #list then
		error("resvec index out of bounds")
	end
	local v = { _table = self._table, _key = list[i] }
	-- TODO: compute the appropriate metatable
	return setmetatable(v, getmetatable(self).each)
end
function resvec_mt:create_resvec_mt(mt)
	-- we pass the (already existing) metatable for the subresource
	local new = { each = mt }
	new.__dump = "[38;5;100m<resvec_mt "..mt._table..">[m"
	new.__index = self.index
	return setmetatable(new, self)
end


--Â«Â«1 Methods for resource builders
-- Resource builders (E.g. "item") have the following form:
-- { _table = "items" } -- and they catch the appropriate metatable
local function normalize_changes(changes, dk)
	-- when passed a table of changes from a resource template,
	-- together with the table's default key name,,
	-- normalizes the changes (modifying the input table)
	--
	-- This assumes that dk is not nil.
	--
	-- This returns a pair:
	-- (new row id, modified table)
		-- in all cases we return (new id, new changes):
	if type(changes) == "string" then -- sword("carsomyr")
		return changes, { [dk] = changes }
	end
	local changes1 = changes[1]
	if changes1 ~= nil then
		changes[1] = nil -- this key is now useless, erase it
		-- sword{ "carsomyr", ... } sets name to "carsomyr"
		if changes[dk] == nil then changes[dk] = changes1 end
		return changes1, changes
	end
	local changes_dk = changes[dk]
	if changes_dk ~= nil then
		-- sword { name = "carsomyr", ... }
		return changes_dk, changes
	end
	error("no id given for new resource")
end
function resource_mt:create_resource(key)
	-- Creates a resource from a database row.
	-- this gets invoked as: resourcetype("row")
	--  => getmetatable(resourcetype).__call(resourcetype, "row")
	--  => resource_mt.__call(resourcetype, "row")
	-- so this must be `resource_mt.__call`
	print(green("initializing a value from "..strdump(key)))
	-- TODO: check that the key exists
	local new = { _table = self._table, _key = key }
	return setmetatable(new, self)
end

--Â«Â«1 Updating `simod.schema` and creating all the metatables


local item_mt = resource_mt:create_resource_mt("items")
simod.schema.items.default_key = "name"

local all_resources_mt = {}
for tablename, schema in pairs(simod.schema) do
	-- first pass: create all the (isolated) resource metatables
	all_resources_mt[tablename] = resource_mt:create_resource_mt(tablename)
end
for tablename, schema in pairs(simod.schema) do
	for fn, ft in pairs(schema.fields) do
		if ft == "subresource" then
			all_resources_mt[tablename].subresources[fn] =
				resvec_mt:create_resvec_mt(all_resources_mt[tablename..'_'..fn])
		end
	end
end


-- Â«Â«1 old code
-- local function child_context(tbl, fields, context)
-- 	-- given a table name, values and local context,
-- 	-- produce context for children (by adding the primary)
-- 	if debug then
-- 		print(magenta("building child context"))
-- 		print("tbl is", tbl)
-- 		print("context is ", strdump(context))
-- 		print("primary is", table_schema(tbl).primary)
-- 	end
-- 	local pk = table_schema(tbl).primary
-- 	local ctx = { [pk] = fields[pk] }
-- 	for k, v in pairs(context) do
-- 		ctx[k] = v
-- 	end
-- 	return ctx
-- end
-- -- we need a forward declaration so that `resource_getindex` can find it:
-- local function resource_delete(self)
-- 	local mt = getmetatable(self)
-- 	local sch = table_schema(mt.table)
-- 	print("deleting resource with id [31m"..self._fields[sch.primary].."[m")
-- 	simod.delete(mt.table, self._fields[sch.primary])
-- end
-- local function resource_getindex(self, fieldname)
-- 	-- Implements `$resource.$field`.
-- 	--
-- 	-- This returns either the raw field,
-- 	-- or (when the field designates a subresource)
-- 	-- a contextualized resvec.
-- 	--
-- 	-- first the methods (TODO: implement a proper method table)
-- 	if fieldname == "delete" then return resource_delete end
-- 	local mt = getmetatable(self)
-- 	local sch = table_schema(mt.table)
-- 	print("called getindex("..green(fieldname)..") for resource with name "..blue(mt.table))
-- 	-- `ft` is the field type (if it exists) for the field we are asking
-- 	local ft = sch.fields[fieldname]
-- 	if type(ft) == "table" then
-- 		-- this field designates a subresource;
-- 		-- we build the resvec, with the appropriate metatable
-- 		-- TODO: maybe _parent = self would be even better?
-- 		local resvec = {
-- 			_entries = self._fields[fieldname],
-- 			_context = child_context(mt.table, self._fields, self._context)
-- 		}
-- 		return setmetatable(resvec, mt[fieldname])
-- 	elseif ft ~= nil then
-- 		-- this field designates an ordinary property;
-- 		-- we simply return the value for this property:
-- 		return self._fields[fieldname]
-- 	end
-- end
-- local function resource_setindex(self, fieldname, value)
-- 	-- TODO: if the field points to a subresource, we should definitely do
-- 	-- something with the database
-- 	local mt = getmetatable(self)
-- 	local tbl = mt.table
-- 	local sch = table_schema(tbl)
-- 	local ft = schema_fieldtype(tbl, sch, fieldname)
-- 	self._fields[fieldname] = value
-- 	simod.update(mt.table, self._fields[sch.primary], fieldname, value)
-- end
-- local function insert_rec(tbl, fields, context)
-- 	-- takes as input a resource with its metatable and context and saves
-- 	-- it to the database (recursively if needed) by calling `simod.insert`.
-- 	local sch = table_schema(tbl)
-- 	-- insert main fields (ignoring sub-resources for now)
-- 	-- NOTE: this should set any `auto` context value:
-- 	-- as a precaution we kill any automatic primary key
-- 	local pk = sch.primary
-- 	if sch.fields[pk] == "auto" then fields[pk] = nil end
-- 	simod.insert(tbl, fields, context)
-- 	-- in principe now the primary key is set; set context for sub-resources:
-- 	local subctx = child_context(tbl, fields, context)
-- 
-- 	-- recursively insert all sub-resources
-- 	for fn, ft in pairs(sch.fields) do if type(ft) == "table" then
-- 		print("recursively save subresource: ", fn, strdump(subctx))
-- 		for _, v in ipairs(fields[fn] or {}) do
-- 			insert_rec(ft[1], v, subctx)
-- 		end
-- 	end end
-- end
-- local function normalize_changes(changes, mt)
-- 	-- when passed a table of changes from a resource template,
-- 	-- together with the metatable for this resource type,
-- 	-- normalizes the changes (modifying the input table).
-- 	local tbl = mt.table
-- 	local primary = simod.schema[tbl].primary
-- 	local dk = default_key[tbl]
-- 	
-- 	if dk ~= nil then
-- 		if type(changes) == "string" then -- sword("carsomyr")
-- 			changes = { [dk] = changes }
-- 		elseif changes[dk] == nil and changes[1] ~= nil then
-- 			-- sword { "carsomyr", enchantment = 5 }
-- 			changes[dk] = changes[1]
-- 			changes[1] = nil
-- 		end
-- 		-- if primary key is not defined, then build a new one from
-- 		-- the default field (e.g. item name or something)
-- 		if changes[primary] == nil then
-- 			changes[primary] = changes[dk]
-- -- 		else
-- -- 			resref = changes[primary]; changes[primary] = nil
-- 		end
-- 	end
-- 	-- since input might be a string, it might be passed by value:
-- 	return changes
-- end
-- local function resource_clone(self, changes)
-- --     resource_clone(self, { field1 = value1, ... })
-- --
-- -- Clones the resource `self` while applying the requested modifications.
-- -- This inserts a new resource in the database and returns the new object.
-- --
-- -- A few special cases are also allowed as syntactic sugar:
-- --     resource_clone(self, "name")
-- --     resource_clone(self, { "name", field1 = vlaue1, ... })
-- -- In both these cases, the value "name" is used for both the `default_key`
-- -- (usually the item name, etc.) and the resource reference.
-- 	local mt = getmetatable(self)
-- 	local changes = normalize_changes(changes, mt)
-- 	local tbl = mt.table
-- 	local sch = table_schema(tbl)
-- 
-- 	local fields = {}
-- 	for k,v in pairs(sch.fields) do
-- 		if type(v) == "table" then
-- 			-- we are dealing with a sub-resource
-- 			-- no need to set metatables here: this is done during __index
-- 			print("insert sub-resource "..k..":"..strdump(changes[k]))
-- 			fields[k] = changes[k] or deep_copy(self._fields[k])
-- 		else
-- 			fields[k] = changes[k] or self._fields[k]
-- 		end
-- 		if self._fields[k] == nil then
-- 			error("field \""..k.."\" undefined!")
-- 		end
-- 	end
-- 	-- insert our fresh resource in the database and return it:
-- 	-- note: if the input primary key is `auto` then it is expected to be
-- 	-- `nil` on function call and set by `simod.insert` to the rowid
-- 	local context = deep_copy(self._context)
-- 	print("new context is ", strdump(context))
-- -- 	print("new fields is ", strdump(fields))
-- 	insert_rec(tbl, fields, context)
-- 	return setmetatable({ _fields = fields, _context = context }, mt)
-- end
-- 
-- -- forward declaration for mutual recursion with create_resource_mt
-- local create_resvec_mt
-- local function create_resource_mt(prop)
-- 	if type(prop) == "string" then
-- 		prop = { table = prop }
-- 	end
-- 	assert(type(prop.table) == "string", "resource should have 'table' defined")
-- 	local sch = table_schema(prop.table)
-- 	prop.__index = resource_getindex
-- 	prop.__newindex = resource_setindex
-- 	prop.__call = resource_clone
-- 	for fn,ft in pairs(sch.fields) do
-- 		if type(ft) == "table" then
-- 			prop[fn] = create_resvec_mt { table = ft[1] }
-- 		end
-- 	end
-- -- 	prop.index = -- mkfn("prop("..prop.table..").index")
-- -- 		function(self, key) print("called index("..prop.table..", [31m"..key.."[m)") end
-- 	return prop
-- end
-- --Â«Â«1 Methods for resource vectors
-- local function resvec_len(self)
-- 	return #self._entries
-- end
-- local function resvec_getindex(self, key)
-- 	local mt = getmetatable(self)
-- 	if type(key) == type(0) then
-- 		-- make it zero-indexed:
-- 		return setmetatable({ _fields = self._entries[key+1],
-- 			_context = self._context}, mt.item)
-- 	else
-- 		return mt[key]
-- 	end
-- end
-- local function resvec_push(self, value)
-- 	-- in addition to the push we need to insert the values,
-- 	-- together with the parent info (self.parent)
-- 	local mt = getmetatable(self)
-- 	table.insert(self._entries, value)
-- 	insert_rec(mt.item.table, value, self._context)
-- end
-- local function resvec_iterate(self)
-- 	local i = 0
-- 	return function()
-- 		i = i+1
-- 		return self._entries[i]
-- 	end
-- end
-- function create_resvec_mt(prop)
-- 	-- builds the metatable for a particular resvec type (indexed by
-- 	-- a schema table name); mutually recursive with `create_resource_mt`
-- 	if type(prop) == "string" then
-- 		prop = { table = prop }
-- 	end
-- 	assert(type(prop.table) == "string",
-- 		"resource vector should have 'table' defined")
-- 	table_schema(prop.table)
-- 	prop.__index = resvec_getindex
-- 	prop.iterate = resvec_iterate
-- 	prop.push = resvec_push
-- 	prop.len = resvec_len
-- 	prop.item = create_resource_mt { table = prop.table }
-- 	return prop
-- end
-- --Â«Â«1 Individual resource types
-- -- Each call to `create_resource_mt` recursively creates the metatables
-- -- for all subresources as well.
-- -- item_mt = create_resource_mt { table = "items" }
-- 
-- function select_all(tbl, parent)
-- 	-- returns an iterator over all rows from `tbl` with given parent key
-- 	local keys = simod.list(tbl, parent)
-- 	local i = 0
-- 	return function()
-- 		i = i+1
-- 		local k = keys[i]
-- 		if k == nil then return end
-- 		return simod.select(tbl, k)
-- 	end
-- end
-- function item(resref)
-- 	-- the main item creation function
-- 	local fields = simod.select("items", resref)
-- 	local ab = {}
-- 	local eff = {}
-- 	for t in select_all("item_abilities", resref) do
-- 		t.itemref = nil
-- 		t.effects = {}
-- 		table.insert(ab, t)
-- 	end
-- 	for t in select_all("item_effects", resref) do
-- 		t.itemref = nil
-- 		local i = t.abref; t.abref = nil
-- 		if i ~= 0 then
-- 			table.insert(ab[i].effects, t)
-- 		else
-- 			table.insert(eff, t)
-- 		end
-- 	end
-- 	fields.abilities = ab
-- 	fields.effects = eff
-- 	return setmetatable({ _fields = fields, _context = {} }, item_mt)
-- end
-- 
--Â«Â«1 Test code
function test_core()
	function group(x) print(red(bold("\ntesting "..x))) end
	group("simod.list")
		print(blue("listing a few item IDs:"))
		local v = simod.list("items")
		print(v[1], v[2], v[3], v[4])
-- 	local obj = simod.select("items", "sw1h34")
-- 	dump(obj)
		print(blue("listing abilities from sw1h34:"))
		local v2 = simod.list("items_abilities", "sw1h34")
		dump(v2)
		print(blue("listing effects of ability ", v2[2]))
		local v3 = simod.list("items_abilities_effects", v2[2])
		dump(v3)
	group("simod.select")
		print(blue("selecting item sw1h34:"))
		local x = simod.select("items", "sw1h34")
		dump(x)
	group("simod.get")
		local x = simod.get("items", "name", "sw1h34")
		dump(x)
	group("simod.set")
		local x = simod.set("items", "name", "sw1h34", "strange sword!")
		dump(x)
		print(blue("now sw1h34 name is:"))
		local x = simod.get("items", "name", "sw1h34")
		dump(x)
	group("simod.schema is:")
		dump(simod.schema)
end
function test_objects()
	-- show schema
	for k, v in pairs(simod.schema) do
		print(k, v.primary, strdump(v.context))
	end
	-- test item cloning
	sword = item("sw1h34")
	sword.weight = 18
-- 	d"sword"
	assert(sword.weight == 18)
-- 	d"sword.abilities[1].use_icon"
	sword.abilities[1].use_icon="spwi101b"
	carsomyr1 = sword("crasomyr")
	ab = carsomyr1.abilities[1]
	print(bold(red("computing effect now:")))
	debug=true
	ef = ab.effects[0]
	print(bold(red("computing effect done!")))
	dump(ef._context)
	if true then return end
-- 	d"crasomyr1"
	assert(carsomyr1.itemref == "crasomyr")
	assert(carsomyr1.name == "crasomyr")
	assert(carsomyr1.abilities[0]._context.itemref == carsomyr1.itemref)
	carsomyr2 = sword{"crasomyr", weight=200, itemref="cars2"}
	print("cocou")
	assert(carsomyr2.itemref == "cars2")
	assert(carsomyr2.name == "crasomyr")
	assert(carsomyr2.weight == 200)
	assert(carsomyr2.abilities[0]._context.itemref == carsomyr2.itemref)
	print("delete!")
	carsomyr2:delete()
	print("after delete")
end
-- test_core()
local albruin = setmetatable({_table="items", _key="sw1h34"}, all_resources_mt.items)

function all_resources_mt.items:foo()
	print("blah! an i am:", strdump(self))
end
ab = albruin.abilities
-- dump(albruin.abilities)
print(magenta("getmetatable(albruin):"))
dump(getmetatable(albruin))
print(magenta("getmetatable(albruin.abilities):"))
dump(getmetatable(ab))
ab1 = ab[1]
dump(ab1.use_icon)
albruin:foo()
-- dump(getmetatable(albruin.abilities))
-- dump(getmetatable(albruin.abilities))
-- local sw1h = item("sw1h01")
-- print(getmetatable(albruin)==item_mt)
-- dump(albruin.abilities)
-- dump(albruin{"toto", weight=100})

-- print(getmetatable(albruin)==item_mt)
-- print(getmetatable(albruin)==resource_mt)
