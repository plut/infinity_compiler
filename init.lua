function loadstring(s) return load(s) end
--[[ todo

 - each res/subres is aware of its SQL primary key
   (needed for update)
 - it also has an `index` which serves only for sorting
 
 - subresources
 - control type on assignment
 - assign an object to a resref field: use obj.resref

API for subresources:
 - item.abilities.len(...)
 - item.abilities.push(...)
 - item.abilities[i] i = 0...
 - item.abilities.iterate()
]]--
--Â«Â«1 Preamble
local function strdump(o)
  if type(o) == 'table' then
    local s = '{ '
    local i = 1
    for k,v in pairs(o) do
      if k == i then
        i = i+1
      elseif type(k) == 'string' then
        s = s..'[32m'..k..'[m='
      else
        s = s..'[[32m'..k..'[m]='
      end
      s = s.. strdump(v)..', '
    end
    return s .. '} '
  elseif type(o) == 'string' then
    return '[34m"'..o..'"[m'
  else
    return tostring(o)
  end
end

local function dump(o)
	print(strdump(o))
end
local function evaldump(s)
	print("[35m"..s.."[m:", strdump(loadstring("return "..s)()))
end
d = evaldump
local function count(tbl)
	local l = 0
	for _, _ in pairs(tbl) do l = l+1 end
	return l
end
local function deep_copy(tbl)
	-- âš  WARNING, this naive implementation does not support cycles!!
	local res = { }
	for k, v in pairs(tbl) do
		if type(v) == "table" then
			res[k] = deep_copy(v)
		else
			res[k] = v
		end
	end
	return res
end

local function mkfn(name)
	return function(...)
	  print("[33;1m"..name.."[m called with: "..strdump(arg))
	end
end
local function mkdisplay(prefix)
	return function(...)
		local s = ""
		for i, v in ipairs({...}) do
			s = s .. tostring(v)
		end
		return "["..prefix.."m"..s.."[m"
	end
end
local red = mkdisplay("31")
local green = mkdisplay("32")
local yellow = mkdisplay("33")
local blue = mkdisplay("34")
local magenta = mkdisplay("35")
local cyan = mkdisplay("36")
local bold = mkdisplay("1")
--Â«Â«1 simulate a mini-version of simod's api
local simod_simul = {}
-- local simod = simod_simul -- comment this line when using real simod
local function table_schema(tbl)
	local sch = simod.schema[tbl]
	if sch == nil then
		error("unknown table: "..tostring(tbl))
	end
	return sch
end
local function schema_fieldtype(tbl, schema, key)
	local v = schema.fields[key]
	if v == nil then
		error("unknown key '"..key.."' in table '"..tbl.."'")
	end
	return v
end
simod_simul.schema = {
-- The schema for a resource includes both payload and context fields.
-- The low-level database interface does not distinguish between these
-- fields; it is the task of the higher-level functions to separate them
-- (when selecting) and collect them (when inserting).
	items = { primary = "itemref", fields =
		{ itemref = "resref", name = "strref", price = "integer",
			weight = "integer", abilities = { "item_abilities" },
		}},
	item_abilities = { primary = "abref", fields =
		{ abref = "auto", itemref = "resref",
			range = "integer", use_icon = "resref", effects = { "item_effects" },
		}},
	item_effects = { primary = "effectref", fields =
		{ effectref = "auto", itemref = "resref", abref = "integer",
			opcode = "integer", target = "integer" }},
}
-- FIXME (?): the schema generated by the Rust side does not contain any
-- link in the (resources) â†’ (subresources) direction;
-- we insert those manually instead:

-- TODO: reinsert this
-- simod.schema.items.fields.abilities = { "item_abilities" }
-- simod.schema.items.fields.effects = { "item_effects" }
-- simod.schema.item_abilities.fields.effects = { "item_effects" }

function simod_simul.list(tbl, condition)
	if tbl == "items" then
		assert(condition == nil)
		return {"sw1h34", "ring", "key"}
	elseif tbl == "item_abilities" then
		assert(condition ~= nil)
		if condition == "sw1h34" then
			return { 1, 2 }
		else return {} end
	elseif tbl == "item_effects" then
		assert(condition ~= nil)
		if condition == "sw1h34" then
			return { 1, 2, 3, 4 }
		end
	end
end
local pseudo_db = {
	items = {
		sw1h34 = { price = 3, weight = 5, name = "Albruin" },
	}, item_abilities = {
		{ itemref = "sw1h34", range = 3, use_icon = "ranged" },
		{ itemref = "sw1h34", range = 0, use_icon = "melee" },
	}, item_effects = {
		{ itemref = "sw1h34", abref = 1, opcode = 1, target = 1 },
		{ itemref = "sw1h34", abref = 1, opcode = 2, target = 1 },
		{ itemref = "sw1h34", opcode = 25, target = 25 },
		{ itemref = "sw1h34", opcode = 26, target = 25 },
	}
}
function simod_simul.select(tbl, resref)
	assert(tbl ~= nil, "nil table in simod.select")
	local sch = table_schema(tbl)
	local fields = {}
	local row = pseudo_db[tbl][resref]
	if row == nil then
		error("pseudo entry not found: "..tbl..":"..resref)
	end
	row = deep_copy(row)
	row[sch.primary] = resref
	return row
end
function simod_simul.update(tbl, resref, key, value)
	assert(tbl ~= nil, "nil table in simod.update")
	local sch = table_schema(tbl)
	if resref == nil then
		error("cannot update resref with nil key in table '"..tbl.."'")
	end
	local ft = schema_fieldtype(tbl, sch, key)
	print(bold('update "', tbl, '" set "', key, "\"='", value,
		"' where \"", sch.primary, "\"='", resref, "'"))
end
function simod_simul.insert(tbl, fields, context)
	assert(tbl ~= nil, "nil tbl in simod.insert")
	local sch = table_schema(tbl)
-- 	print("[35msimod.insert("..tbl.."):[m\n  context="..strdump(context))
	local s1 = "insert into "..tbl.."("
	local s2 = ") values ("
	for fn, ft in pairs(sch.fields) do
		if ft == "auto" then
			-- set new auto field:
			fields[fn] = math.random(10)+300
		elseif type(ft) ~= "table" then
			local v = fields[fn] or context[fn]
			if v == nil then
				error("insert into tbl '"..tbl.."': value not found for '"..fn.."'")
			end
			s1 = s1..'"'..fn..'", '
			s2 = s2.."'"..v.."', "
		else
-- 			print("[36m -- ignoring vector data for field: '"..tbl.."'.'"..fn.."' ("..count(fields[fn]).." entries)[m")
		end
	end
	print(bold(s1, s2))
end

--Â«Â«1 Methods for resources
-- Resource objects store their data in two main fields:
--  - `_context` for read-only information located to the resource's
--  place in the database;
--  - for individual resources, `_fields` for accessible data;
--  - for resource vectors (resvecs), `_entries` (as an array).
--
-- When accessing the database (through one of the `simod.*` functions)
-- all these fields are handled together. It is our job to group them
-- (when inserting in the database) or separate them (when reading).
--
-- Rationale for context:
--  - when extracted from its structure, a field must be able to function
--    independently (e.g. inserting a new item ability) and still report to
--    the database.
--  - resvecs might be empty, so we cannot store context only in
--    individual resources.
--  - we still might allow resref to be user-accessible so we put it
--    outside of context and in `_fields`. (Plus, this makes reading top
--    resources slightly easier).
--
local default_key = {
	-- The default field used to generate resrefs when none are specified.
	-- (This is only syntactic sugar for the item cloning functions).
	items = "name",
}
local function child_context(tbl, fields, context)
	-- given a table name, values and local context,
	-- produce context for children (by adding the primary)
	if debug then
		print(magenta("building child context"))
		print("tbl is", tbl)
		print("context is ", strdump(context))
		print("primary is", table_schema(tbl).primary)
	end
	local pk = table_schema(tbl).primary
	local ctx = { [pk] = fields[pk] }
	for k, v in pairs(context) do
		ctx[k] = v
	end
	return ctx
end
-- we need a forward declaration so that `resource_getindex` can find it:
local function resource_delete(self)
	local mt = getmetatable(self)
	local sch = table_schema(mt.table)
	print("deleting resource with id [31m"..self._fields[sch.primary].."[m")
	simod.delete(mt.table, self._fields[sch.primary])
end
local function resource_getindex(self, fieldname)
	-- Implements `$resource.$field`.
	-- 
	-- This returns either the raw field,
	-- or (when the field designates a subresource)
	-- a contextualized resvec.
	-- first the methods
	if fieldname == "delete" then return resource_delete end
	local mt = getmetatable(self)
	local sch = table_schema(mt.table)
	print("called getindex("..green(fieldname)..") for resource with name "..blue(mt.table))
	-- `ft` is the field type (if it exists) for the field we are asking
	local ft = sch.fields[fieldname]
	if type(ft) == "table" then
		-- this field designates a subresource;
		-- we build the resvec, with the appropriate metatable
		-- TODO: maybe _parent = self would be even better?
		local resvec = {
			_entries = self._fields[fieldname],
			_context = child_context(mt.table, self._fields, self._context)
		}
		return setmetatable(resvec, mt[fieldname])
	elseif ft ~= nil then
		-- this field designates an ordinary property;
		-- we simply return the value for this property:
		return self._fields[fieldname]
	end
end
local function resource_setindex(self, fieldname, value)
	-- TODO: if the field points to a subresource, we should definitely do
	-- something with the database
	local mt = getmetatable(self)
	local tbl = mt.table
	local sch = table_schema(tbl)
	local ft = schema_fieldtype(tbl, sch, fieldname)
	self._fields[fieldname] = value
	simod.update(mt.table, self._fields[sch.primary], fieldname, value)
end
local function insert_rec(tbl, fields, context)
	-- takes as input a resource with its metatable and context and saves
	-- it to the database (recursively if needed) by calling `simod.insert`.
	local sch = table_schema(tbl)
	-- insert main fields (ignoring sub-resources for now)
	-- NOTE: this should set any `auto` context value:
	-- as a precaution we kill any automatic primary key
	local pk = sch.primary
	if sch.fields[pk] == "auto" then fields[pk] = nil end
	simod.insert(tbl, fields, context)
	-- in principe now the primary key is set; set context for sub-resources:
	local subctx = child_context(tbl, fields, context)

	-- recursively insert all sub-resources
	for fn, ft in pairs(sch.fields) do if type(ft) == "table" then
		print("recursively save subresource: ", fn, strdump(subctx))
		for _, v in ipairs(fields[fn] or {}) do
			insert_rec(ft[1], v, subctx)
		end
	end end
end
local function normalize_changes(changes, mt)
	-- when passed a table of changes from a resource template,
	-- together with the metatable for this resource type,
	-- normalizes the changes (modifying the input table).
	local tbl = mt.table
	local primary = simod.schema[tbl].primary
	local dk = default_key[tbl]
	
	if dk ~= nil then
		if type(changes) == "string" then -- sword("carsomyr")
			changes = { [dk] = changes }
		elseif changes[dk] == nil and changes[1] ~= nil then
			-- sword { "carsomyr", enchantment = 5 }
			changes[dk] = changes[1]
			changes[1] = nil
		end
		-- if primary key is not defined, then build a new one from
		-- the default field (e.g. item name or something)
		if changes[primary] == nil then
			changes[primary] = changes[dk]
-- 		else
-- 			resref = changes[primary]; changes[primary] = nil
		end
	end
	-- since input might be a string, it might be passed by value:
	return changes
end
local function resource_clone(self, changes)
--     resource_clone(self, { field1 = value1, ... })
--
-- Clones the resource `self` while applying the requested modifications.
-- This inserts a new resource in the database and returns the new object.
--
-- A few special cases are also allowed as syntactic sugar:
--     resource_clone(self, "name")
--     resource_clone(self, { "name", field1 = vlaue1, ... })
-- In both these cases, the value "name" is used for both the `default_key`
-- (usually the item name, etc.) and the resource reference.
	local mt = getmetatable(self)
	local changes = normalize_changes(changes, mt)
	local tbl = mt.table
	local sch = table_schema(tbl)

	local fields = {}
	for k,v in pairs(sch.fields) do
		if type(v) == "table" then
			-- we are dealing with a sub-resource
			-- no need to set metatables here: this is done during __index
			print("insert sub-resource "..k..":"..strdump(changes[k]))
			fields[k] = changes[k] or deep_copy(self._fields[k])
		else
			fields[k] = changes[k] or self._fields[k]
		end
		if self._fields[k] == nil then
			error("field \""..k.."\" undefined!")
		end
	end
	-- insert our fresh resource in the database and return it:
	-- note: if the input primary key is `auto` then it is expected to be
	-- `nil` on function call and set by `simod.insert` to the rowid
	local context = deep_copy(self._context)
	print("new context is ", strdump(context))
-- 	print("new fields is ", strdump(fields))
	insert_rec(tbl, fields, context)
	return setmetatable({ _fields = fields, _context = context }, mt)
end

-- forward declaration for mutual recursion with create_resource_mt
local create_resvec_mt
local function create_resource_mt(prop)
	if type(prop) == "string" then
		prop = { table = prop }
	end
	assert(type(prop.table) == "string", "resource should have 'table' defined")
	local sch = table_schema(prop.table)
	prop.__index = resource_getindex
	prop.__newindex = resource_setindex
	prop.__call = resource_clone
	for fn,ft in pairs(sch.fields) do
		if type(ft) == "table" then
			prop[fn] = create_resvec_mt { table = ft[1] }
		end
	end
-- 	prop.index = -- mkfn("prop("..prop.table..").index")
-- 		function(self, key) print("called index("..prop.table..", [31m"..key.."[m)") end
	return prop
end
--Â«Â«1 Methods for resource vectors
local function resvec_len(self)
	return #self._entries
end
local function resvec_getindex(self, key)
	local mt = getmetatable(self)
	if type(key) == type(0) then
		-- make it zero-indexed:
		return setmetatable({ _fields = self._entries[key+1],
			_context = self._context}, mt.item)
	else
		return mt[key]
	end
end
local function resvec_push(self, value)
	-- in addition to the push we need to insert the values,
	-- together with the parent info (self.parent)
	local mt = getmetatable(self)
	table.insert(self._entries, value)
	insert_rec(mt.item.table, value, self._context)
end
local function resvec_iterate(self)
	local i = 0
	return function()
		i = i+1
		return self._entries[i]
	end
end
function create_resvec_mt(prop)
	-- builds the metatable for a particular resvec type (indexed by
	-- a schema table name); mutually recursive with `create_resource_mt`
	if type(prop) == "string" then
		prop = { table = prop }
	end
	assert(type(prop.table) == "string",
		"resource vector should have 'table' defined")
	table_schema(prop.table)
	prop.__index = resvec_getindex
	prop.iterate = resvec_iterate
	prop.push = resvec_push
	prop.len = resvec_len
	prop.item = create_resource_mt { table = prop.table }
	return prop
end
--Â«Â«1 Individual resource types
-- Each call to `create_resource_mt` recursively creates the metatables
-- for all subresources as well.
item_mt = create_resource_mt { table = "items" }

function select_all(tbl, parent)
	-- returns an iterator over all rows from `tbl` with given parent key
	local keys = simod.list(tbl, parent)
	local i = 0
	return function()
		i = i+1
		local k = keys[i]
		if k == nil then return end
		return simod.select(tbl, k)
	end
end
function item(resref)
	-- the main item creation function
	local fields = simod.select("items", resref)
	local ab = {}
	local eff = {}
	for t in select_all("item_abilities", resref) do
		t.itemref = nil
		t.effects = {}
		table.insert(ab, t)
	end
	for t in select_all("item_effects", resref) do
		t.itemref = nil
		local i = t.abref; t.abref = nil
		if i ~= 0 then
			table.insert(ab[i].effects, t)
		else
			table.insert(eff, t)
		end
	end
	fields.abilities = ab
	fields.effects = eff
	return setmetatable({ _fields = fields, _context = {} }, item_mt)
end

--Â«Â«1 Test code
function test_core()
	local v = simod.list("items")
	print(v[1], v[2], v[3])
end
function test_objects()
	-- show schema
	for k, v in pairs(simod.schema) do
		print(k, v.primary, strdump(v.context))
	end
	-- test item cloning
	sword = item("sw1h34")
	sword.weight = 18
-- 	d"sword"
	assert(sword.weight == 18)
-- 	d"sword.abilities[1].use_icon"
	sword.abilities[1].use_icon="spwi101b"
	carsomyr1 = sword("crasomyr")
	ab = carsomyr1.abilities[1]
	print(bold(red("computing effect now:")))
	debug=true
	ef = ab.effects[0]
	print(bold(red("computing effect done!")))
	dump(ef._context)
	if true then return end
-- 	d"crasomyr1"
	assert(carsomyr1.itemref == "crasomyr")
	assert(carsomyr1.name == "crasomyr")
	assert(carsomyr1.abilities[0]._context.itemref == carsomyr1.itemref)
	carsomyr2 = sword{"crasomyr", weight=200, itemref="cars2"}
	print("cocou")
	assert(carsomyr2.itemref == "cars2")
	assert(carsomyr2.name == "crasomyr")
	assert(carsomyr2.weight == 200)
	assert(carsomyr2.abilities[0]._context.itemref == carsomyr2.itemref)
	print("delete!")
	carsomyr2:delete()
	print("after delete")
end
-- print("blah")
-- test()
-- print("==============")
-- sword.abilities:push { range = 9, use_icon="!!new!!",
-- 	effects = { { opcode = 55, target = 55 } } }
-- sword.abilities[2].effects:push { opcode = 57, target = 57 }
-- print(sword.abilities[2].effects:len())
-- d"sword.abilities[2]"

-- dump(simod.select("item_effects", 31))
