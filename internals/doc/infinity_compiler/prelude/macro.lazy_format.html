<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Lazily format something. Essentially the same as `format!`, except that instead of formatting its arguments to a string, it captures them in an opaque struct, which can be formatted later. This allows you to build up formatting operations without any intermediary allocations or extra formatting calls. Also supports lazy conditional and looping constructs."><meta name="keywords" content="rust, rustlang, rust-lang, lazy_format"><title>lazy_format in infinity_compiler::prelude - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-6827029ac823cab7.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../static.files/light-ebce58d0a40c3431.css"><link rel="stylesheet" disabled href="../../static.files/dark-f23faae4a2daf9a6.css"><link rel="stylesheet" disabled href="../../static.files/ayu-8af5e100b21cd173.css"><script id="default-settings" ></script><script src="../../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-c55e1eb52e1886b4.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc macro"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../infinity_compiler/index.html"><div class="logo-container"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../infinity_compiler/index.html"><div class="logo-container"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><div class="sidebar-elems"><h2><a href="index.html">In infinity_compiler::prelude</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Macro <a href="../index.html">infinity_compiler</a>::<wbr><a href="index.html">prelude</a>::<wbr><a class="macro" href="#">lazy_format</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><div class="item-decl"><div class="example-wrap"><pre class="rust macro"><code><span class="macro">macro_rules! </span>lazy_format {
    (<span class="macro-nonterminal">$pattern</span>:literal $(, $(<span class="macro-nonterminal">$args</span>:tt)<span class="kw-2">*</span>)<span class="question-mark">?</span>) =&gt; { ... };
    (<span class="kw">match </span>(<span class="macro-nonterminal">$condition</span>:expr) {
        $($(
            <span class="macro-nonterminal">$match_pattern</span>:pat
            $(<span class="kw">if </span><span class="macro-nonterminal">$guard</span>:expr)<span class="question-mark">?
            </span>=&gt; <span class="macro-nonterminal">$output</span>:tt
        ),+ $(,)<span class="question-mark">?</span>)<span class="question-mark">?
    </span>}) =&gt; { ... };
    (
        <span class="kw">if </span>$(<span class="kw">let </span><span class="macro-nonterminal">$</span><span class="kw">match</span>:<span class="macro-nonterminal">pat </span>= )<span class="question-mark">? </span><span class="macro-nonterminal">$condition</span>:expr =&gt; <span class="macro-nonterminal">$output</span>:tt
        $(<span class="kw">else if </span>$(<span class="kw">let </span><span class="macro-nonterminal">$elseif_match</span>:pat = )<span class="question-mark">? </span><span class="macro-nonterminal">$elseif_condition</span>:expr =&gt; <span class="macro-nonterminal">$elseif_output</span>:tt)*
        $(<span class="kw">else </span>=&gt; <span class="macro-nonterminal">$else_output</span>:tt)<span class="question-mark">?
    </span>) =&gt; { ... };
    (<span class="macro-nonterminal">$output</span>:tt <span class="kw">for </span><span class="macro-nonterminal">$item</span>:pat <span class="kw">in </span><span class="macro-nonterminal">$collection</span>:expr) =&gt; { ... };
}</code></pre></div>
</div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Lazily format something. Essentially the same as <a href="https://doc.rust-lang.org/std/macro.format.html"><code>format!</code></a>, except that
instead of formatting its arguments to a string, it captures them in an opaque
struct, which can be formatted later. This allows you to build up formatting
operations without any intermediary allocations or extra formatting calls. Also
supports lazy conditional and looping constructs.</p>
<p>The return value of this macro is left deliberately unspecified and
undocumented. The most important this about it is its <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a>
implementation, which executes the deferred formatting operation. It also
provides a <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a> implementation, which simply prints the
<a href="macro.lazy_format.html" title="lazy_format!"><code>lazy_format!</code></a><code>(...)</code> call without evaluating any of its arguments, as well
as <a href="https://doc.rust-lang.org/1.67.1/core/clone/trait.Clone.html" title="Clone"><code>Clone</code></a> and <a href="https://doc.rust-lang.org/1.67.1/core/marker/trait.Copy.html" title="Copy"><code>Copy</code></a> if those traits are available in the captured
context.</p>
<p>Note that this macro is completely lazy; it captures the expressions to
be formatted in the struct and doesn’t evaluate them until the struct is
actually written to a <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> or <a href="https://doc.rust-lang.org/std/fs/struct.File.html"><code>File</code></a> or or other writable destination.
This means that the argument expression will be evaluated <em>every</em> time the
instance is written, which may not be what you want; be sure to eagerly perform
any 1-time calculations you want to before calling <code>lazy_format!</code>.</p>
<h2 id="basic-example"><a href="#basic-example">Basic example:</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fmt::Display;
<span class="kw">use </span>lazy_format::lazy_format;

<span class="kw">fn </span>get_hello() -&gt; String {
    String::from(<span class="string">&quot;Hello&quot;</span>)
}

<span class="kw">fn </span>get_world() -&gt; String {
    String::from(<span class="string">&quot;World&quot;</span>)
}

<span class="kw">fn </span>hello_world() -&gt; <span class="kw">impl </span>Display {
    <span class="macro">lazy_format!</span>(<span class="string">&quot;{}, {w}!&quot;</span>, get_hello(), w = get_world())
}

<span class="kw">let </span>result = hello_world();

<span class="comment">// get_hello and get_world aren&#39;t called until the object is
// formatted into a String.
</span><span class="kw">let </span>result_str = result.to_string();
<span class="macro">assert_eq!</span>(result_str, <span class="string">&quot;Hello, World!&quot;</span>);</code></pre></div>
<p>Just like with regular formatting, <code>lazy_format</code> can automatically, implicitly
capture named parameters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::{size_of_val, size_of};
<span class="kw">use </span>lazy_format::lazy_format;

<span class="kw">let </span>a = <span class="number">10</span>;
<span class="kw">let </span>b = <span class="number">20</span>;

<span class="kw">let </span>result = <span class="macro">lazy_format!</span>(<span class="string">&quot;{a} {b}&quot;</span>);
<span class="macro">assert_eq!</span>(size_of_val(<span class="kw-2">&amp;</span>result), size_of::&lt;i32&gt;() * <span class="number">2</span>);
<span class="macro">assert_eq!</span>(result.to_string(), <span class="string">&quot;10 20&quot;</span>);</code></pre></div>
<h2 id="demonstation-of-lazy-capturing"><a href="#demonstation-of-lazy-capturing">Demonstation of lazy capturing:</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fmt::Display;
<span class="kw">use </span>std::mem::{size_of_val, size_of};
<span class="kw">use </span>lazy_format::lazy_format;


<span class="kw">fn </span>get_formatted() -&gt; <span class="kw">impl </span>Display {
    <span class="kw">let </span>a: isize = <span class="number">10</span>;
    <span class="kw">let </span>b: isize = <span class="number">15</span>;

    <span class="macro">lazy_format!</span>(<span class="string">&quot;10 + 15: {v}, again: {v}&quot;</span>, v = (a + b))
}

<span class="kw">let </span>result = get_formatted();

<span class="comment">// The result captures 2 isize values (a and b) from get_formatted.
</span><span class="macro">assert_eq!</span>(size_of_val(<span class="kw-2">&amp;</span>result), size_of::&lt;isize&gt;() * <span class="number">2</span>);

<span class="kw">let </span>result_str = result.to_string();
<span class="macro">assert_eq!</span>(result_str, <span class="string">&quot;10 + 15: 25, again: 25&quot;</span>);</code></pre></div>
<h2 id="conditional-formatting"><a href="#conditional-formatting">Conditional formatting</a></h2>
<p><code>lazy_format!</code> supports conditional formatting with <code>match</code>- or <code>if</code>-
style syntax. When doing a conditional format, add the formatting pattern
and arguments directly into the <code>match</code> arms or <code>if</code> blocks, rather than
code; this allows conditional formatting to still be captured in a single
static type.</p>
<h3 id="match-conditional-example"><a href="#match-conditional-example"><code>match</code> conditional example:</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fmt::Display;
<span class="kw">use </span>lazy_format::lazy_format;

<span class="kw">fn </span>get_number(num: usize) -&gt; <span class="kw">impl </span>Display {
    <span class="comment">// Note that the parenthesis in the match conditional are required,
    // due to limitations in Rust&#39;s macro parsing (can&#39;t follow an
    // expression with `{}`)
    </span><span class="macro">lazy_format!</span>(<span class="kw">match </span>(num) {
        <span class="number">0 </span>=&gt; <span class="string">&quot;Zero&quot;</span>,
        <span class="number">1 </span>=&gt; <span class="string">&quot;One&quot;</span>,
        <span class="number">2 </span>=&gt; <span class="string">&quot;Two&quot;</span>,
        <span class="number">3 </span>=&gt; <span class="string">&quot;Three&quot;</span>,
        <span class="number">4 </span>| <span class="number">5 </span>=&gt; <span class="string">&quot;Four or five&quot;</span>,
        value <span class="kw">if </span>value % <span class="number">2 </span>== <span class="number">0 </span>=&gt; (<span class="string">&quot;A large even number: {}&quot;</span>, value),
        value =&gt; <span class="string">&quot;An unrecognized number: {value}&quot;</span>,
    })
}

<span class="macro">assert_eq!</span>(get_number(<span class="number">0</span>).to_string(), <span class="string">&quot;Zero&quot;</span>);
<span class="macro">assert_eq!</span>(get_number(<span class="number">1</span>).to_string(), <span class="string">&quot;One&quot;</span>);
<span class="macro">assert_eq!</span>(get_number(<span class="number">2</span>).to_string(), <span class="string">&quot;Two&quot;</span>);
<span class="macro">assert_eq!</span>(get_number(<span class="number">3</span>).to_string(), <span class="string">&quot;Three&quot;</span>);
<span class="macro">assert_eq!</span>(get_number(<span class="number">4</span>).to_string(), <span class="string">&quot;Four or five&quot;</span>);
<span class="macro">assert_eq!</span>(get_number(<span class="number">5</span>).to_string(), <span class="string">&quot;Four or five&quot;</span>);
<span class="macro">assert_eq!</span>(get_number(<span class="number">6</span>).to_string(), <span class="string">&quot;A large even number: 6&quot;</span>);
<span class="macro">assert_eq!</span>(get_number(<span class="number">7</span>).to_string(), <span class="string">&quot;An unrecognized number: 7&quot;</span>);</code></pre></div>
<h3 id="if-conditional-example"><a href="#if-conditional-example"><code>if</code> conditional example:</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fmt::Display;
<span class="kw">use </span>lazy_format::lazy_format;

<span class="kw">fn </span>describe_number(value: isize) -&gt; <span class="kw">impl </span>Display {
    <span class="macro">lazy_format!</span>(
        <span class="kw">if </span>value &lt; <span class="number">0 </span>=&gt; (<span class="string">&quot;A negative number: {}&quot;</span>, value)
        <span class="kw">else if </span>value % <span class="number">3 </span>== <span class="number">0 </span>=&gt; (<span class="string">&quot;A number divisible by 3: {}&quot;</span>, value)
        <span class="kw">else if </span>value % <span class="number">2 </span>== <span class="number">1 </span>=&gt; (<span class="string">&quot;An odd number: {}&quot;</span>, value)
        <span class="kw">else </span>=&gt; <span class="string">&quot;Some other kind of number&quot;
    </span>)
}

<span class="macro">assert_eq!</span>(describe_number(-<span class="number">2</span>).to_string(), <span class="string">&quot;A negative number: -2&quot;</span>);
<span class="macro">assert_eq!</span>(describe_number(-<span class="number">1</span>).to_string(), <span class="string">&quot;A negative number: -1&quot;</span>);
<span class="macro">assert_eq!</span>(describe_number(<span class="number">0</span>).to_string(), <span class="string">&quot;A number divisible by 3: 0&quot;</span>);
<span class="macro">assert_eq!</span>(describe_number(<span class="number">1</span>).to_string(), <span class="string">&quot;An odd number: 1&quot;</span>);
<span class="macro">assert_eq!</span>(describe_number(<span class="number">2</span>).to_string(), <span class="string">&quot;Some other kind of number&quot;</span>);
<span class="macro">assert_eq!</span>(describe_number(<span class="number">3</span>).to_string(), <span class="string">&quot;A number divisible by 3: 3&quot;</span>);</code></pre></div>
<p><code>if</code> formatters are allowed to exclude the final <code>else</code> branch, in which
case <code>lazy_format</code> will simply write an empty string:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fmt::Display;
<span class="kw">use </span>lazy_format::lazy_format;

<span class="kw">fn </span>only_evens(value: i32) -&gt; <span class="kw">impl </span>Display {
    <span class="macro">lazy_format!</span>(<span class="kw">if </span>value % <span class="number">2 </span>== <span class="number">0 </span>=&gt; (<span class="string">&quot;An even number: {}&quot;</span>, value))
}

<span class="macro">assert_eq!</span>(only_evens(<span class="number">10</span>).to_string(), <span class="string">&quot;An even number: 10&quot;</span>);
<span class="macro">assert_eq!</span>(only_evens(<span class="number">5</span>).to_string(), <span class="string">&quot;&quot;</span>);</code></pre></div>
<h3 id="if-let-conditional-example"><a href="#if-let-conditional-example"><code>if let</code> conditional example:</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fmt::Display;
<span class="kw">use </span>lazy_format::lazy_format;

<span class="kw">fn </span>describe_optional_number(value: <span class="prelude-ty">Option</span>&lt;isize&gt;) -&gt; <span class="kw">impl </span>Display {
    <span class="macro">lazy_format!</span>(
        <span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="number">10</span>) = value =&gt; <span class="string">&quot;It&#39;s ten!&quot;
        </span><span class="kw">else if let </span><span class="prelude-val">Some</span>(<span class="number">3</span>) | <span class="prelude-val">Some</span>(<span class="number">4</span>) = value =&gt; <span class="string">&quot;It&#39;s three or four!&quot;
        </span><span class="kw">else if let </span>| <span class="prelude-val">Some</span>(<span class="number">0</span>) = value =&gt; <span class="string">&quot;It&#39;s zero!&quot;
        </span><span class="kw">else if let </span><span class="prelude-val">Some</span>(x) = value =&gt; (<span class="string">&quot;It&#39;s some other value: {}&quot;</span>, x)
        <span class="kw">else </span>=&gt; <span class="string">&quot;It&#39;s not a number!&quot;
    </span>)
}

<span class="macro">assert_eq!</span>(describe_optional_number(<span class="prelude-val">Some</span>(<span class="number">10</span>)).to_string(), <span class="string">&quot;It&#39;s ten!&quot;</span>);
<span class="macro">assert_eq!</span>(describe_optional_number(<span class="prelude-val">Some</span>(<span class="number">3</span>)).to_string(), <span class="string">&quot;It&#39;s three or four!&quot;</span>);
<span class="macro">assert_eq!</span>(describe_optional_number(<span class="prelude-val">Some</span>(<span class="number">4</span>)).to_string(), <span class="string">&quot;It&#39;s three or four!&quot;</span>);
<span class="macro">assert_eq!</span>(describe_optional_number(<span class="prelude-val">Some</span>(<span class="number">0</span>)).to_string(), <span class="string">&quot;It&#39;s zero!&quot;</span>);
<span class="macro">assert_eq!</span>(describe_optional_number(<span class="prelude-val">Some</span>(<span class="number">5</span>)).to_string(), <span class="string">&quot;It&#39;s some other value: 5&quot;</span>);
<span class="macro">assert_eq!</span>(describe_optional_number(<span class="prelude-val">None</span>).to_string(), <span class="string">&quot;It&#39;s not a number!&quot;</span>);</code></pre></div>
<h2 id="looping-formatting"><a href="#looping-formatting">Looping formatting</a></h2>
<p><code>lazy_format!</code> supports formatting elements in a collection with a loop:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fmt::Display;
<span class="kw">use </span>lazy_format::lazy_format;

<span class="kw">let </span>list = <span class="macro">vec!</span>[<span class="number">1i32</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];
<span class="kw">let </span>list_ref = <span class="kw-2">&amp;</span>list;

<span class="comment">// Format each element in the iterable without additional arguments to `format_args`
</span><span class="kw">let </span>simple_semicolons = <span class="macro">lazy_format!</span>(<span class="string">&quot;{v}; &quot; </span><span class="kw">for </span>v <span class="kw">in </span>list_ref.iter().map(|x| x - <span class="number">1</span>));
<span class="macro">assert_eq!</span>(simple_semicolons.to_string(), <span class="string">&quot;0; 1; 2; 3; &quot;</span>);

<span class="comment">// Perform a full format with additional arguments on each element in the iterable.
</span><span class="kw">let </span>header = <span class="string">&quot;Value&quot;</span>;
<span class="kw">let </span>full_format = <span class="macro">lazy_format!</span>((<span class="string">&quot;{}: {}; &quot;</span>, header, v) <span class="kw">for </span>v <span class="kw">in </span>list_ref);
<span class="macro">assert_eq!</span>(full_format.to_string(), <span class="string">&quot;Value: 1; Value: 2; Value: 3; Value: 4; &quot;</span>);</code></pre></div>
<p>Note that these looping formatters are not suitable for doing something like
a comma separated list, since they’ll apply the formatting to all elements.
For a lazy string joining library, which only inserts separators between
elements in a list, check out <a href="/joinery">joinery</a>.</p>
</div></details></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="infinity_compiler" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.1 (d5a82bbd2 2023-02-07)" data-search-js="search-444266647c4dba98.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>